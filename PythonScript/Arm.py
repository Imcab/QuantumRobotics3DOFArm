# -*- coding: utf-8 -*-
"""ArmKinematics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U9s8F-KdbA6mt_OJaJPn8hsixiKunqy3
"""
import matplotlib.pyplot as plt
import math as m

#Longitudes de los eslabones
L1 = 5
L2 = 4
L3 = 2

def forwardKinematics(theta1, theta2, theta3):

  ftheta1 = m.radians(theta1)
  ftheta2 = m.radians(theta2)
  ftheta3 = m.radians(theta3)

  #Sacamos los componentes del vector
  x1 = L1 * m.cos(ftheta1)
  y1 = L1 * m.sin(ftheta1)

  #Se le suma el componente anterior porque el vector empieza donde acaba el otro
  x2 = x1 + L2 * m.cos(ftheta1 + ftheta2)
  y2 = y1 + L2 * m.sin(ftheta1 + ftheta2)

  #El angulo de los eslabones se acumula, dandonos la cinemática del brazo
  x3 = x2 + L3 * m.cos(ftheta1 + ftheta2 + ftheta3)
  y3 = y2 + L3 * m.sin(ftheta1 + ftheta2 +  ftheta3)

  #Regresa la cinematica del brazo con 0,0 como origen
  return [(0,0) , (x1,y1) , (x2, y2), (x3, y3)]


#Para calcular la cinematica inversa debemos
#de dividir el brazo e ignorar por el momento el tercer eslabon,
#el primero y el segundo formaran el nuevo "brazo" y la
# punta será la muñeca

def inverseKinematics(x,y,angle, armDOWN):

  #Solve for wrist
  phi = m.radians(angle)

  wristX = x - L3 * m.cos(phi)
  wristY = y - L3 * m.sin(phi)

  #Distancia (hipotenusa)
  distanceSquare = wristX*wristX + wristY*wristY

  distance = m.sqrt(distanceSquare)

  #Ley de cosenos para sacar la direccion
  direction = (distanceSquare - (L1*L1) - (L2*L2)) / (2*L1*L2)

  #Si la hipotenusa es mayor al alcance maximo de nuestro brazo, no es posible.
  if distance > L1+L2+L3:
    return None

  #Clamp al output
  direction = max(-1.0, min(1.0, direction))

  #Calcular el angulo 2

  s2Magnitude = m.sqrt(max(0,1 - (direction * direction)))

  #Escoger entre diferentes configuraciónes para el brazo
  s2 = s2Magnitude if armDOWN == True else -s2Magnitude

  theta2 = m.atan2(s2, direction)

  #Calcular para el resto de angulos
  k1 = L1 + L2 * direction
  k2 = L2 * s2

  theta1 = m.atan2(wristY, wristX) - m.atan2(k2, k1)

  #Calcular el angulo de la punta
  theta3 = phi - theta1 - theta2

  #Regresar los angulos

  return (m.degrees(theta1), m.degrees(theta2), m.degrees(theta3))

def graph(mKinematics):
  xs = [p[0] for p in mKinematics]
  ys = [p[1] for p in mKinematics]

  plt.plot(xs, ys, marker='o')
  plt.xlim(-sum([L1,L2,L3]), sum([L1,L2,L3]))
  plt.ylim(-sum([L1,L2,L3]), sum([L1,L2,L3]))
  plt.grid(True)
  plt.xlabel("X")
  plt.ylabel("Y")
  plt.title("Brazo Robótico 3DOF")
  plt.gca().set_aspect('equal', adjustable='box')
  plt.show()

  for i, (x, y) in enumerate(mKinematics):
    print(f"Punto {i}: x={x:.2f}, y={y:.2f}")

#Ejemplo de uso
kinematics = forwardKinematics(90,-45,90)

graph(kinematics)

#Cinematica Inversa Ejemplo
iK = inverseKinematics(5,2,180,True)

#Imprimir los angulos
print("Cinematica Inversa Angulos:", iK)

#Comprobar la cinemática directa con los angulos obtenidos
newKinematics = forwardKinematics(*iK)

print("End effector:", newKinematics[-1])

#Graficarla
graph(newKinematics)